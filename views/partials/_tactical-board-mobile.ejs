<!-- MOBILE-ONLY Tactical Board Modal -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Mobile Tactical Board</title>
  <style>
    /* prevent body scroll when modal open */
    body.modal-open {
      overflow: hidden;
      height: 100vh;
    }

    /* hide modal by default */
    #tacticalModal {
      display: none;
    }

    /* only show and style on mobile screens up to 768px */
    @media only screen and (max-width: 768px) {
      #tacticalModal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100dvh;
        background: rgba(0, 0, 0, 0.85);
        z-index: 9999;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .tactical-header {
        flex: 0 0 auto;
        padding: 10px;
        background: #fff;
        text-align: right;
        border-bottom: 1px solid #ccc;
      }
      .tactical-header button {
        font-size: 18px;
        padding: 6px 12px;
        border: none;
        background: #e74c3c;
        color: white;
        border-radius: 6px;
      }

      .tactical-controls {
        flex: 0 0 auto;
        display: flex;
        overflow-x: auto;
        padding: 10px;
        background: #fff;
        gap: 8px;
      }
      .tactical-controls button,
      .tactical-controls select,
      .tactical-controls input[type="color"] {
        flex: 0 0 auto;
        padding: 10px;
        font-size: 16px;
        border-radius: 8px;
        border: 1px solid #888;
        background: #f9f9f9;
        font-weight: bold;
        cursor: pointer;
      }
      .tactical-controls button {
        background: linear-gradient(to bottom, #007BFF, #0056b3);
        color: white;
        border: none;
      }

      #tacticalPitch {
        flex: 1 1 auto;
        position: relative;
        background: #003300;
        padding: 5px;
      }
      #tacticalCanvas {
        width: 100%;
        height: 100%;
        aspect-ratio: 16/9;
        background: url('/images/tactical-pitch.png') center/cover no-repeat;
        border-radius: 12px;
        touch-action: none;
        display: block;
      }

      #nameInput {
        position: absolute;
        display: none;
        z-index: 10001;
        font-size: 16px;
        padding: 5px 8px;
        border: 1px solid #aaa;
        border-radius: 6px;
        background: white;
        pointer-events: auto;
      }
    }
  </style>
</head>
<body>
  <!-- trigger button (hidden on desktop) -->
  <button id="openTacticalBoardBtn" style="display:none; position: fixed; bottom: 20px; right: 20px; padding: 12px 18px; background:#007BFF; color:#fff; border:none; border-radius:50%; font-size:24px; z-index:10000;">⚽</button>

  <div id="tacticalModal">
    <div class="tactical-header">
      <button onclick="closeTacticalBoard()">✕ Close</button>
    </div>
    <div class="tactical-controls">
      <select onchange="loadFormation(this.value)">
        <option value="433">4-3-3</option>
        <option value="433f9">4-3-3 False 9</option>
        <option value="442">4-4-2</option>
        <option value="4231">4-2-3-1</option>
        <option value="532">5-3-2</option>
        <option value="523">5-2-3</option>
      </select>
      <input type="color" id="teamColorPicker" onchange="changeTeamColor(this.value)" value="#007BFF" />
      <button onclick="toggleArrowMode()">Arrow: <span id="arrowModeStatus">Off</span></button>
      <button onclick="toggleNamingMode()">Name: <span id="namingModeStatus">Off</span></button>
      <select id="textColorPicker" onchange="changeTextColor(this.value)">
        <option value="white" selected>Text White</option>
        <option value="black">Text Black</option>
      </select>
      <button onclick="undo()">Undo</button>
      <button onclick="redo()">Redo</button>
      <button onclick="submitTactics()">Submit</button>
    </div>
    <div id="tacticalPitch">
      <canvas id="tacticalCanvas"></canvas>
      <input id="nameInput" type="text" placeholder="Enter name" />
    </div>
  </div>

  <script>
    // --- STATE & SETUP ---
    let draggedPlayer = null, dragOffsetX = 0, dragOffsetY = 0;
    let undoStack = [], redoStack = [];
    let playerColor = '#007BFF', playerNameColor = 'white';
    let arrowMode = false, namingMode = false;
    let arrows = [], arrowStart = null, tempArrowEnd = null;
    const players = [];
    let currentFormationCode = '433';
    let canvas, ctx;

    const pitchImage = new Image();
    pitchImage.src = '/images/tactical-pitch.png';
    pitchImage.onload = () => { if (canvas && ctx) drawPlayers(); };

    function captureState() {
      return {
        players: players.map(p => ({ x: p.x, y: p.y, label: p.label, name: p.name })),
        arrows: arrows.map(a => ({ start: {...a.start}, end: {...a.end} }))
      };
    }

    // --- MODES & COLORS ---
    function changeTeamColor(color) { playerColor = color; drawPlayers(); }
    function changeTextColor(color) { playerNameColor = color; drawPlayers(); }

    function toggleNamingMode() {
      namingMode = !namingMode;
      if (namingMode) {
        arrowMode = false;
        document.getElementById('arrowModeStatus').innerText = 'Off';
        alert('Naming mode ON: Tap a player to name.');
      }
      document.getElementById('namingModeStatus').innerText = namingMode ? 'On' : 'Off';
    }

    function toggleArrowMode() {
      arrowMode = !arrowMode;
      if (arrowMode) {
        namingMode = false;
        document.getElementById('namingModeStatus').innerText = 'Off';
      }
      document.getElementById('arrowModeStatus').innerText = arrowMode ? 'On' : 'Off';
    }

    // --- DRAWING ---
    function drawArrow(start, end) {
      const headlen = 15;
      const dx = end.x - start.x, dy = end.y - start.y;
      const angle = Math.atan2(dy, dx);
      ctx.strokeStyle = 'red'; ctx.lineWidth = 4;
      ctx.beginPath(); ctx.moveTo(start.x, start.y); ctx.lineTo(end.x, end.y); ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(end.x, end.y);
      ctx.lineTo(end.x - headlen * Math.cos(angle - Math.PI/6), end.y - headlen * Math.sin(angle - Math.PI/6));
      ctx.lineTo(end.x - headlen * Math.cos(angle + Math.PI/6), end.y - headlen * Math.sin(angle + Math.PI/6));
      ctx.lineTo(end.x, end.y);
      ctx.fillStyle = 'red'; ctx.fill();
    }

    function drawPlayers() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (pitchImage.complete && pitchImage.naturalWidth) {
        ctx.drawImage(pitchImage, 0, 0, canvas.width, canvas.height);
      } else {
        ctx.fillStyle = '#2c6f2c';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
      arrows.forEach(a => drawArrow(a.start, a.end));
      if (arrowStart && tempArrowEnd) drawArrow(arrowStart, tempArrowEnd);
      players.forEach(p => {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 30, 0, Math.PI * 2);
        ctx.fillStyle = playerColor;
        ctx.fill();
        ctx.strokeStyle = 'white'; ctx.lineWidth = 2; ctx.stroke();
        ctx.fillStyle = playerNameColor;
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(p.name || p.label, p.x, p.y);
      });
    }

    // --- UNDO/REDO ---
    function undo() {
      if (undoStack.length < 2) return;
      redoStack.push(captureState());
      undoStack.pop();
      const prev = undoStack[undoStack.length-1];
      players.length = 0; arrows.length = 0;
      prev.players.forEach(p => players.push({...p}));
      prev.arrows.forEach(a => arrows.push({start:{...a.start}, end:{...a.end}}));
      drawPlayers();
    }
    function redo() {
      if (!redoStack.length) return;
      undoStack.push(captureState());
      const next = redoStack.pop();
      players.length = 0; arrows.length = 0;
      next.players.forEach(p => players.push({...p}));
      next.arrows.forEach(a => arrows.push({start:{...a.start}, end:{...a.end}}));
      drawPlayers();
    }

    // --- FORMATIONS ---
    function loadFormation(code) {
      const midY = canvas.height / 2;
      const lineX = [60,180,300,420,540,660,780];
      if (players.length) undoStack.push(captureState());
      redoStack.length = 0;
      players.length = 0;
      currentFormationCode = code;
      const formations = {
        '433': [ ['GK',0,0],['LB',2,-170],['CB',1,-60],['CB',1,60],['RB',2,170],['CM',3,-100],['CDM',2,0],['CM',3,100],['LW',4,-150],['RW',4,150],['ST',5,0] ],
        '433f9': [ ['GK',0,0],['LB',2,-170],['LCB',1,-60],['RCB',1,60],['RB',2,170],['CM',3,-100],['CDM',2,0],['CM',3,100],['LW',5,-130],['RW',5,130],['False 9',4,0] ],
        '442': [ ['GK',0,0],['LB',2,-170],['CB',1,-60],['CB',1,60],['RB',2,170],['LM',4,-170],['CDM',3,-60],['CDM',3,60],['RM',4,170],['ST',5,-60],['ST',5,60] ],
        '4231':[ ['GK',0,0],['LB',2,-170],['CB',1,-60],['CB',1,60],['RB',2,170],['CDM',3,-60],['CDM',3,60],['CAM',4,0],['LM',4,-170],['RM',4,170],['ST',5,0] ],
        '532':[ ['GK',0,0],['LWB',3,-190],['LCB',2,-110],['CB',1,0],['RCB',2,110],['RWB',3,190],['CM',4,-110],['CDM',3,0],['CM',4,110],['ST',5,-60],['ST',5,60] ],
        '523':[ ['GK',0,0],['LWB',3,-190],['LCB',2,-110],['CB',1,0],['RCB',2,110],['RWB',3,190],['CM',3,-70],['CM',3,70],['LW',4,-120],['RW',4,120],['ST',5,0] ]
      };
      formations[code].forEach(([label,xIdx,yOff]) => {
        players.push({ x: lineX[xIdx], y: midY + yOff, label, name: '' });
      });
      drawPlayers();
      undoStack.push(captureState());
    }

    // --- NAMING ---
    function showNameInput(p) {
      setTimeout(() => {
        const input = document.getElementById('nameInput');
        const rect = canvas.getBoundingClientRect();
        const scaleX = rect.width / canvas.width;
        const scaleY = rect.height / canvas.height;
        const screenX = p.x * scaleX;
        const screenY = p.y * scaleY;
        input.style.left = (screenX - 60) + 'px';
        input.style.top = (screenY - 40) + 'px';
        input.value = p.name || '';
        input.style.display = 'block';
        input.focus();
        input.onkeydown = ev => {
          if (ev.key === 'Enter') {
            p.name = input.value.trim(); input.style.display='none';
            drawPlayers(); undoStack.push(captureState()); redoStack.length=0;
          } else if (ev.key === 'Escape') {
            input.style.display='none';
          }
        };
      }, 10);
    }

    // --- SUBMISSION ---
    function submitTactics() {
      drawPlayers();
      canvas.toBlob(blob => {
        const taskInput = document.getElementById('tacticImageInput');
        if (!taskInput) return;
        const dt = new DataTransfer();
        dt.items.add(new File([blob], 'tactic.png', { type: 'image/png' }));
        taskInput.files = dt.files;

        let preview = document.getElementById('tacticImagePreview');
        if (!preview) {
          preview = document.createElement('img');
          preview.id = 'tacticImagePreview';
          preview.style.maxWidth = '200px'; preview.style.marginTop='10px'; preview.style.borderRadius='12px';
          const comment = document.getElementById('commentText');
          comment.parentNode.insertBefore(preview, comment.nextSibling);
        }
        if (preview.src) URL.revokeObjectURL(preview.src);
        preview.src = URL.createObjectURL(blob);
        preview.style.display = 'block';
        closeTacticalBoard();
        alert('Tactic image attached to your comment!');
      });
    }

    // --- MOBILE MODAL CONTROL ---
    function openMobileTacticalBoard() {
      if (window.innerWidth > 768) return;
      document.body.classList.add('modal-open');
      document.getElementById('tacticalModal').style.display = 'flex';
      setTimeout(initCanvas, 10);
    }
    function closeTacticalBoard() {
      document.body.classList.remove('modal-open');
      document.getElementById('tacticalModal').style.display = 'none';
    }
    function initCanvas() {
      canvas = document.getElementById('tacticalCanvas');
      ctx = canvas.getContext('2d');
      resizeCanvas();
      if (!undoStack.length) loadFormation('433');
      setupDragListeners();
    }
    function resizeCanvas() {
      canvas.width = canvas.clientWidth * devicePixelRatio;
      canvas.height = canvas.clientHeight * devicePixelRatio;
      ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
      drawPlayers();
    }
    window.addEventListener('resize', resizeCanvas);

    function setupDragListeners() {
      canvas.addEventListener('mousedown', startDrag);
      canvas.addEventListener('touchstart', startDrag, { passive: false });
      canvas.addEventListener('mousemove', doDrag);
      canvas.addEventListener('touchmove', doDrag, { passive: false });
      canvas.addEventListener('mouseup', endDrag);
      canvas.addEventListener('touchend', endDrag);
      canvas.addEventListener('mouseleave', endDrag);
    }

    function rectify(e) {
      e.preventDefault();
      const touch = e.touches && e.touches[0] ? e.touches[0] : e;
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      return { x: (touch.clientX - rect.left) * scaleX, y: (touch.clientY - rect.top) * scaleY };
    }

    function startDrag(e) {
      const { x, y } = rectify(e);
      if (arrowMode) { arrowStart = { x, y }; return; }
      if (namingMode) {
        for (let p of players) {
          if (Math.hypot(x - p.x, y - p.y) < 30) { showNameInput(p); return; }
        }
        return;
      }
      for (let p of players) {
        if (Math.hypot(x - p.x, y - p.y) < 30) {
          draggedPlayer = p; dragOffsetX = x - p.x; dragOffsetY = y - p.y; break;
        }
      }
    }
    function doDrag(e) {
      if (!arrowMode && !draggedPlayer) return;
      const { x, y } = rectify(e);
      if (arrowMode && arrowStart) { tempArrowEnd = { x, y }; drawPlayers(); return; }
      if (draggedPlayer) { draggedPlayer.x = x - dragOffsetX; draggedPlayer.y = y - dragOffsetY; drawPlayers(); }
    }
    function endDrag(e) {
      if (arrowMode && arrowStart) {
        const { x, y } = rectify(e);
        arrows.push({ start: arrowStart, end: { x, y } });
        arrowStart = tempArrowEnd = null;
        undoStack.push(captureState());
        drawPlayers();
      }
      if (draggedPlayer) { draggedPlayer = null; undoStack.push(captureState()); }
    }

    document.addEventListener('DOMContentLoaded', () => {
      const btn = document.getElementById('openTacticalBoardBtn');
      if (btn) {
        btn.style.display = 'block';
        btn.addEventListener('click', openTacticalBoard);
      }
    });
  </script>
</body>
</html>
